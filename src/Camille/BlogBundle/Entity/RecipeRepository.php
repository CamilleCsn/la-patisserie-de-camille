<?php

namespace Camille\BlogBundle\Entity;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\Tools\Pagination\Paginator;
use InvalidArgumentException;
use Doctrine\ORM\QueryBuilder;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;


/**
 * RecipeRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class RecipeRepository extends EntityRepository
{

    /**
   * Récupère une liste d'articles triés et paginés.
   *
   * @param int $page Le numéro de la page
   * @param int $nbMaxParPage Nombre maximum d'article par page     
   *
   * @throws InvalidArgumentException
   * @throws NotFoundHttpException
   *
   * @return Paginator
   */
  public function findAllPagineEtTrie($page, $nbMaxParPage)
  {
    if (!is_numeric($page)) {
        throw new InvalidArgumentException(	
            'La valeur de l\'argument $page est incorrecte (valeur : ' . $page . ').'
        );
    }

    if ($page < 1) {
        throw new NotFoundHttpException('La page demandée n\'existe pas');
    }

    if (!is_numeric($nbMaxParPage)) {
        throw new InvalidArgumentException(
            'La valeur de l\'argument $nbMaxParPage est incorrecte (valeur : ' . $nbMaxParPage . ').'
        );
    }

    $qb = $this->createQueryBuilder('a')
        ->orderBy('a.date', 'DESC');
    
    $query = $qb->getQuery();

    $premierResultat = ($page - 1) * $nbMaxParPage;
    $query->setFirstResult($premierResultat)->setMaxResults($nbMaxParPage);
    $paginator = new Paginator($query);

    if ( ($paginator->count() <= $premierResultat) && $page != 1) {
        throw new NotFoundHttpException('La page demandée n\'existe pas.'); // page 404, sauf pour la première page
    }

    return $paginator;
  }

	public function getRecipeWithCategories(array $categoryNames){
		//cette fonction retourne un tableau de Recipe

		$qb = $this->createQueryBuilder('r');

		//on fait une jointure avec l'entité Category avec pour alias "c"
		$qb
     		->join('r.categories', 'c')
      		->addSelect('c')
    	;

		//puis on filtre sur le nom des catégories à l'aide d'un IN
		$qb->where($qb->expr()->in('c.name', $categoryNames));

		//on retourne le résultat
		return $qb
			->getQuery()
			->getResult()
		;
	}

	public function whereCurrentYear(QueryBuilder $qb){
		
		$qb
			->andWhere('r.date BETWEEN :start AND :end')
			->setParameter('start', new \DateTime(date('Y').'-01-01'))
			//date entre le 1er janvier de cette année
			->setParameter('end', new \DateTime(date('Y').'-12-31'))
			//et le 31 décembre de cette année
		;
	}

	public function myFind(){
		$qb = $this->createQueryBuilder('r');

		//on peut ajouter ce qu'on veut avant
		$qb
			->where('r.author = :author')
			->setParameter('author', 'Emma');
		;

		//on applique notre condition sur le QueyBuilder
		$this->whereCurrentYear($qb);

		//on peut ajouter ce qu'on veut après
		$qb->orderBy('r.date', 'DESC');

		return $qb
			->getQuery()
			->getResult()
		;
	}
	// public function myFindAll() {

	// 	//methode 1 : en passant par l'EntityManager
	// 	// $queryBuilder = $this->_em->createQueryBuilder()
	// 	// 	->select('r')
	// 	// 	->from($this->_entityName, 'r')
	// 	// ;	
	// 	//dans un repository, $this->_entityName est le namespsace de l'entitée gérée
	// 	//ici, il vaut donc Camille\BlogBundle\Entity\Recipe

	// 	//methode 2 : en passant par le raccourcis (recommandé)
	// 	$queryBuilder = $this->createQueryBuilder('r');

	// 	//on ajoute pas de critère ou tri particulier, la construction
	// 	//de la requête est finie

	// 	//on récupère la query à partir du QueryBuilder
	// 	$query = $queryBuilder->getQuery();

	// 	//on récupère les résulats à partir de la Query
	// 	$results = $query->getResults();

	// 	//on retourne ces résultats
	// 	return $results;

	// 	//PAREIL mais sans commentaires et raccourcis
	// 	// return $this
	// 	// 	->createQueryBuilder('r')
	// 	// 	->getQuery()
	// 	// 	->getResult()
	// 	// ;

	// }

	// public function myFindOne($id){
	// 	$qb = $this->createQueryBuilder('r');

	// 	$qb
	// 		->where('r.id = :id')
	// 		->setParameter('id', $id)
	// 	;

	// 	return $qb
	// 		->getQuery()
	// 		->getResult()
	// 	;	
	// }

	// public function findByAuthorAndDate($author, $year){
	// 	$qb = $this->createQueryBuilder('r');

	// 	$qb
	// 		->where('r.author = :author')
	// 			->setParameter('author', $author)
	// 		->andWhere('r.date < :year')
	// 			->setParameter('year', $year)
	// 		->orderBy('r.date', 'DESC')
	// 	;

	// 	return $qb
	// 		->getQuery()
	// 		->getResult()
	// 	;

	// }


}
